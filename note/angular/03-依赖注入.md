# 1. Angular 中的依赖注入
依赖项是指某个类执行其功能所需的服务或对象。依赖项注入（DI）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们。

Angular 的 DI 框架会在实例化某个类时为其提供依赖。可以使用 Angular DI 来提高应用程序的灵活性和模块化程度。

## 1.1 创建可注入服务
要想在 `src/app/heroes` 目录下生成一个新的 `HeroService` 类，请使用下列 `Angular CLI `命令。
`ng generate service heroes/hero`下列命令会创建默认的 HeroService。
```ts
//src/app/heroes/hero.service.ts (CLI-generated)
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class HeroService {
  constructor() { }
}
```
`@Injectable()` 装饰器会指定 `Angular` 可以在 DI 体系中使用此类。元数据 `providedIn: 'root'` 表示 `HeroService` 在整个应用程序中都是可见的。
```ts
//接下来，要获取英雄的模拟数据，请添加一个 getHeroes() 方法，该方法会从 mock.heroes.ts 中返回英雄。
import { Injectable } from '@angular/core';
import { HEROES } from './mock-heroes';

@Injectable({
  // declares that this service should be created
  // by the root application injector.
  providedIn: 'root',
})
export class HeroService {
  getHeroes() { return HEROES; }
}
```
为了清晰和可维护性，建议你在单独的文件中定义组件和服务。

如果你确实要将组件和服务合并在同一个文件中，则必须先定义服务，再定义组件，这一点很重要。如果在服务之前定义组件，Angular 将返回运行时的空引用错误。

## 1.2 注入服务
注入某些服务会使它们对组件可见。

要将依赖项注入组件的 `constructor()` 中，请提供具有此依赖项类型的构造函数参数。下面的示例在 `HeroListComponent` 的构造函数中指定了 `HeroService`。`heroService` 的类型是` HeroService`。
```ts
//src/app/heroes/hero-list.component (constructor signature)
constructor(heroService: HeroService)

//注入服务
export class HeroListComponent{
    heroes: Hero[];

    constructor(heroService: HeroService){
        this.heroes = heroService.getHeroes();
    }


}
```

## 1.3 在其他服务中使用这些服务
当某个服务依赖于另一个服务时，请遵循与注入组件相同的模式。在这里，HeroService 要依靠 Logger 服务来报告其活动。

1. 导入 Logger 服务。接下来，通过在括号中指定 private logger: Logger，来在 HeroService 的 constructor() 中注入 Logger 服务。
2. 当创建一个其 constructor() 带有参数的类时，请指定其类型和关于这些参数的元数据，以便 Angular 可以注入正确的服务。在这里，constructor() 指定了 Logger 的类型，并把 Logger 的实例存储在名叫 logger 的私有字段中。

```ts
//下列代码具有 Logger 服务和两个版本的 HeroService。HeroService 的第一个版本不依赖于 Logger 服务。修改后的第二个版本依赖于 Logger 服务。

//src/app/logger.service
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class Logger {
  logs: string[] = []; // capture logs for testing

  log(message: string) {
    this.logs.push(message);
    console.log(message);
  }
}

//src/app/logger.service(v1)
import { Injectable } from '@angular/core';
import { HEROES } from './mock-heroes';

@Injectable({
  providedIn: 'root',
})
export class HeroService {
  getHeroes() { return HEROES; }
}

//src/app/logger.service(v2)
import { Injectable } from '@angular/core';
import { HEROES } from './mock-heroes';
import { Logger } from '../logger.service';

@Injectable({
  providedIn: 'root',
})
export class HeroService {

  constructor(private logger: Logger) {  }

  getHeroes() {
    this.logger.log('Getting heroes ...');
    return HEROES;
  }
}
```
# 2. DI 提供者
依赖提供者

通过配置提供者，你可以把服务提供给那些需要它们的应用部件。

依赖提供者会使用 DI 令牌来配置注入器，注入器会用它来提供这个依赖值的具体的、运行时版本。

## 2.1 指定提供者令牌
如果你把服务类指定为提供者令牌，那么注入器的默认行为是用 new 来实例化那个类。

在下面这个例子中，Logger 类提供了 Logger 的实例。
`providers: [Logger]`

不过，你也可以用一个替代提供者来配置注入器，这样就可以指定另一些同样能提供日志功能的对象

可以使用服务类来配置注入器，也可以提供一个替代类、一个对象或一个工厂函数

## 2.2 依赖注入令牌
当使用提供者配置注入器时，会将该提供者与依赖项注入令牌（或叫 DI 令牌）关联起来。注入器允许 Angular 创建任何内部依赖项的映射。DI 令牌会充当该映射的键名。

依赖项值是一个实例，而这个类的类型用作查找键。在这里，注入器使用 HeroService 类型作为令牌来查找 heroService

```ts
//src/app/injector.component.ts
heroService: HeroService;

//当你使用 HeroService 类的类型来定义构造函数参数时，Angular 会注入与这个 HeroService 类令牌相关联的服务：
//src/app/heroes/hero-list.component.ts
constructor(heroService: HeroService)
```

## 2.3 定义提供者
类提供者的语法实际上是一种简写形式，它会扩展成一个由 Provider 接口定义的提供者配置对象。下面的代码片段展示了 providers 中给出的类会如何扩展成完整的提供者配置对象。
```ts
providers: [Logger]
//Angular 把这个 providers 值扩展为一个完整的提供者对象，如下所示。
[{ provide: Logger, useClass: Logger }]
```
扩展的提供者配置是一个具有两个属性的对象字面量：

1. provide 属性存有令牌，它作为一个 key，在定位依赖值和配置注入器时使用。

2. 第二个属性是一个提供者定义对象，它告诉注入器要如何创建依赖值。提供者定义对象中的 key 可以是 useClass —— 就像这个例子中一样。也可以是 useExisting、useValue 或 useFactory。每一个 key 都用于提供一种不同类型的依赖，我们稍后会讨论。

## 2.4 指定替代性的类提供者
不同的类可以提供相同的服务。比如，以下代码告诉注入器，当组件使用 Logger 令牌请求一个 logger 时，给它返回一个 BetterLogger。
`[{ provide: Logger, useClass: BetterLogger }]`

### 2.4.1 配置带依赖的类提供者

如果替代类提供者有自己的依赖，那就在父模块或组件的元数据属性 providers 中指定那些依赖。
```ts
[ UserService,
  { provide: Logger, useClass: EvenBetterLogger }]
//在这个例子中，EvenBetterLogger 会在日志信息里显示用户名。这个 logger 要从注入的 UserService 实例中来获取该用户。
@Injectable()
export class EvenBetterLogger extends Logger {
  constructor(private userService: UserService) { super(); }

  override log(message: string) {
    const name = this.userService.user.name;
    super.log(`Message to ${name}: ${message}`);
  }
}
//注入器需要提供这个新的日志服务以及该服务所依赖的 UserService 对象
```

### 2.4.2 别名类提供者
要为类提供者设置别名，请在 providers 数组中使用 useExisting 属性指定别名和类提供者。

在下面的例子中，当组件请求新的或旧的记录器时，注入器都会注入一个 NewLogger 的实例。通过这种方式，OldLogger 就成了 NewLogger 的别名。
```ts
[ NewLogger,
  // Alias OldLogger w/ reference to NewLogger
  { provide: OldLogger, useExisting: NewLogger}]

//请确保你没有使用 useClass 来把 OldLogger 设为 NewLogger 的别名，因为如果这样做它就会创建两个不同的 NewLogger 实例。
```

## 2.5 为类接口指定别名
通常，编写同一个父组件别名提供者的变体时会使用forwardRef，如下所示

```ts
//dependency-injection-in-action/src/app/parent-finder.component.ts
providers: [{ provide: Parent, useExisting: forwardRef(() => AlexComponent) }],

//为简化你的代码，可以使用辅助函数 provideParent() 来把这个逻辑提取到一个辅助函数中。

//dependency-injection-in-action/src/app/parent-finder.component.ts
// Helper method to provide the current component instance in the name of a `parentType`.
export function provideParent
  (component: any) {
    return { provide: Parent, useExisting: forwardRef(() => component) };
  }

  //现在，你可以为组件添加一个更容易阅读和理解的父提供者
//dependency-injection-in-action/src/app/parent-finder.component.ts
providers:  [ provideParent(AliceComponent) ]
```

### 2.5.1 为多个类接口指定别名
要为多个父类型指定别名（每个类型都有自己的类接口令牌），请配置 provideParent() 以接受更多的参数。
```ts
//这是一个修订版本，默认值为 parent 但同时也接受另一个父类接口作为可选的第二参数。
// Helper method to provide the current component instance in the name of a `parentType`.
// The `parentType` defaults to `Parent` when omitting the second parameter.
//dependency-injection-in-action/src/app/parent-finder.component.ts
export function provideParent
  (component: any, parentType?: any) {
    return { provide: parentType || Parent, useExisting: forwardRef(() => component) };
  }
//接下来，要使用 provideParent()，请传入第二参数，这里是 DifferentParent。
//dependency-injection-in-action/src/app/parent-finder.component.ts
providers:  [ provideParent(BethComponent, DifferentParent) ]
```

### 2.5.2 注入一个对象
要注入一个对象，可以用 useValue 选项来配置注入器。下面的提供者定义对象使用 useValue 作为 key 来把该变量与 Logger 令牌关联起来。